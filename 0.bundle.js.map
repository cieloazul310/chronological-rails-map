{"version":3,"file":"0.bundle.js","sources":["webpack:///./src/geolocation.js","webpack:///./node_modules/ol/geolocation.js","webpack:///./node_modules/ol/geolocationproperty.js","webpack:///./node_modules/ol/feature.js","webpack:///./node_modules/ol/source/vector.js","webpack:///./node_modules/ol/loadingstrategy.js","webpack:///./node_modules/ol/source/vectoreventtype.js"],"sourcesContent":["import Geol from \"ol/geolocation\";\nimport Feature from \"ol/feature\";\nimport Style from \"ol/style/style\";\nimport Circle from \"ol/style/circle\";\nimport Fill from \"ol/style/fill\";\nimport Stroke from \"ol/style/stroke\"\nimport PointGeom from \"ol/geom/point\";\nimport VectorLayer from \"ol/layer/vector\";\nimport VectorSource from \"ol/source/vector\";\n\nexport default (state) => {\n\n    const geolocation = new Geol({\n      projection: state.getMap().getView().getProjection()\n    });\n\n    const positionFeature = new Feature();\n    positionFeature.setStyle([\n      new Style({\n        image: new Circle({\n          radius: 12,\n          fill: new Fill({\n            color: 'rgba(51, 181, 204, 0.4)'\n          })\n        })\n      }),\n      new Style({\n        image: new Circle({\n          radius: 6,\n          fill: new Fill({\n            color: '#3399CC'\n          }),\n          stroke: new Stroke({\n            color: '#fff',\n            width: 2\n          })\n        })\n      })\n    ]);\n\n    const menus = document.querySelector(\".menu-container ul.menus\");\n    const li = document.createElement(\"li\");\n    li.innerHTML = \"現在地を表示\";\n    li.addEventListener(\"click\", (evt) => {\n      if (!geolocation.getTracking()) {\n        geolocation.setTracking(true);\n        evt.target.classList.add(\"active\");\n      } else {\n        state.getMap().getView().setCenter(geolocation.getPosition());\n      }\n    });\n\n    menus.appendChild(li);\n\n    geolocation.once(\"change:position\", () => {\n      state.getMap().getView().setCenter(geolocation.getPosition());\n      state.getMap().getView().setZoom(Math.max(12, state.getMap().getView().getZoom()));\n      positionFeature.setGeometry(geolocation.getPosition() ?\n        new PointGeom(geolocation.getPosition()) : null);\n      new VectorLayer({\n        map: state.getMap(),\n        source: new VectorSource({\n          features: [positionFeature]\n        })\n      });\n    });\n\n    geolocation.on('change:position', () => {\n      positionFeature.setGeometry(geolocation.getPosition() ?\n        new PointGeom(geolocation.getPosition()) : null);\n    });\n\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/geolocation.js\n// module id = 237\n// module chunks = 0","// FIXME handle geolocation not supported\n\nimport _ol_ from './index';\nimport _ol_GeolocationProperty_ from './geolocationproperty';\nimport _ol_Object_ from './object';\nimport _ol_Sphere_ from './sphere';\nimport _ol_events_ from './events';\nimport _ol_events_EventType_ from './events/eventtype';\nimport _ol_geom_Polygon_ from './geom/polygon';\nimport _ol_has_ from './has';\nimport _ol_math_ from './math';\nimport _ol_proj_ from './proj';\nimport _ol_proj_EPSG4326_ from './proj/epsg4326';\n\n/**\n * @classdesc\n * Helper class for providing HTML5 Geolocation capabilities.\n * The [Geolocation API](http://www.w3.org/TR/geolocation-API/)\n * is used to locate a user's position.\n *\n * To get notified of position changes, register a listener for the generic\n * `change` event on your instance of `ol.Geolocation`.\n *\n * Example:\n *\n *     var geolocation = new ol.Geolocation({\n *       // take the projection to use from the map's view\n *       projection: view.getProjection()\n *     });\n *     // listen to changes in position\n *     geolocation.on('change', function(evt) {\n *       window.console.log(geolocation.getPosition());\n *     });\n *\n * @fires error\n * @constructor\n * @extends {ol.Object}\n * @param {olx.GeolocationOptions=} opt_options Options.\n * @api\n */\nvar _ol_Geolocation_ = function(opt_options) {\n\n  _ol_Object_.call(this);\n\n  var options = opt_options || {};\n\n  /**\n   * The unprojected (EPSG:4326) device position.\n   * @private\n   * @type {ol.Coordinate}\n   */\n  this.position_ = null;\n\n  /**\n   * @private\n   * @type {ol.TransformFunction}\n   */\n  this.transform_ = _ol_proj_.identityTransform;\n\n  /**\n   * @private\n   * @type {ol.Sphere}\n   */\n  this.sphere_ = new _ol_Sphere_(_ol_proj_EPSG4326_.RADIUS);\n\n  /**\n   * @private\n   * @type {number|undefined}\n   */\n  this.watchId_ = undefined;\n\n  _ol_events_.listen(\n      this, _ol_Object_.getChangeEventType(_ol_GeolocationProperty_.PROJECTION),\n      this.handleProjectionChanged_, this);\n  _ol_events_.listen(\n      this, _ol_Object_.getChangeEventType(_ol_GeolocationProperty_.TRACKING),\n      this.handleTrackingChanged_, this);\n\n  if (options.projection !== undefined) {\n    this.setProjection(options.projection);\n  }\n  if (options.trackingOptions !== undefined) {\n    this.setTrackingOptions(options.trackingOptions);\n  }\n\n  this.setTracking(options.tracking !== undefined ? options.tracking : false);\n\n};\n\n_ol_.inherits(_ol_Geolocation_, _ol_Object_);\n\n\n/**\n * @inheritDoc\n */\n_ol_Geolocation_.prototype.disposeInternal = function() {\n  this.setTracking(false);\n  _ol_Object_.prototype.disposeInternal.call(this);\n};\n\n\n/**\n * @private\n */\n_ol_Geolocation_.prototype.handleProjectionChanged_ = function() {\n  var projection = this.getProjection();\n  if (projection) {\n    this.transform_ = _ol_proj_.getTransformFromProjections(\n        _ol_proj_.get('EPSG:4326'), projection);\n    if (this.position_) {\n      this.set(\n          _ol_GeolocationProperty_.POSITION, this.transform_(this.position_));\n    }\n  }\n};\n\n\n/**\n * @private\n */\n_ol_Geolocation_.prototype.handleTrackingChanged_ = function() {\n  if (_ol_has_.GEOLOCATION) {\n    var tracking = this.getTracking();\n    if (tracking && this.watchId_ === undefined) {\n      this.watchId_ = navigator.geolocation.watchPosition(\n          this.positionChange_.bind(this),\n          this.positionError_.bind(this),\n          this.getTrackingOptions());\n    } else if (!tracking && this.watchId_ !== undefined) {\n      navigator.geolocation.clearWatch(this.watchId_);\n      this.watchId_ = undefined;\n    }\n  }\n};\n\n\n/**\n * @private\n * @param {GeolocationPosition} position position event.\n */\n_ol_Geolocation_.prototype.positionChange_ = function(position) {\n  var coords = position.coords;\n  this.set(_ol_GeolocationProperty_.ACCURACY, coords.accuracy);\n  this.set(_ol_GeolocationProperty_.ALTITUDE,\n      coords.altitude === null ? undefined : coords.altitude);\n  this.set(_ol_GeolocationProperty_.ALTITUDE_ACCURACY,\n      coords.altitudeAccuracy === null ?\n        undefined : coords.altitudeAccuracy);\n  this.set(_ol_GeolocationProperty_.HEADING, coords.heading === null ?\n    undefined : _ol_math_.toRadians(coords.heading));\n  if (!this.position_) {\n    this.position_ = [coords.longitude, coords.latitude];\n  } else {\n    this.position_[0] = coords.longitude;\n    this.position_[1] = coords.latitude;\n  }\n  var projectedPosition = this.transform_(this.position_);\n  this.set(_ol_GeolocationProperty_.POSITION, projectedPosition);\n  this.set(_ol_GeolocationProperty_.SPEED,\n      coords.speed === null ? undefined : coords.speed);\n  var geometry = _ol_geom_Polygon_.circular(\n      this.sphere_, this.position_, coords.accuracy);\n  geometry.applyTransform(this.transform_);\n  this.set(_ol_GeolocationProperty_.ACCURACY_GEOMETRY, geometry);\n  this.changed();\n};\n\n/**\n * Triggered when the Geolocation returns an error.\n * @event error\n * @api\n */\n\n/**\n * @private\n * @param {GeolocationPositionError} error error object.\n */\n_ol_Geolocation_.prototype.positionError_ = function(error) {\n  error.type = _ol_events_EventType_.ERROR;\n  this.setTracking(false);\n  this.dispatchEvent(/** @type {{type: string, target: undefined}} */ (error));\n};\n\n\n/**\n * Get the accuracy of the position in meters.\n * @return {number|undefined} The accuracy of the position measurement in\n *     meters.\n * @observable\n * @api\n */\n_ol_Geolocation_.prototype.getAccuracy = function() {\n  return (\n    /** @type {number|undefined} */ this.get(_ol_GeolocationProperty_.ACCURACY)\n  );\n};\n\n\n/**\n * Get a geometry of the position accuracy.\n * @return {?ol.geom.Polygon} A geometry of the position accuracy.\n * @observable\n * @api\n */\n_ol_Geolocation_.prototype.getAccuracyGeometry = function() {\n  return (\n    /** @type {?ol.geom.Polygon} */ this.get(_ol_GeolocationProperty_.ACCURACY_GEOMETRY) || null\n  );\n};\n\n\n/**\n * Get the altitude associated with the position.\n * @return {number|undefined} The altitude of the position in meters above mean\n *     sea level.\n * @observable\n * @api\n */\n_ol_Geolocation_.prototype.getAltitude = function() {\n  return (\n    /** @type {number|undefined} */ this.get(_ol_GeolocationProperty_.ALTITUDE)\n  );\n};\n\n\n/**\n * Get the altitude accuracy of the position.\n * @return {number|undefined} The accuracy of the altitude measurement in\n *     meters.\n * @observable\n * @api\n */\n_ol_Geolocation_.prototype.getAltitudeAccuracy = function() {\n  return (\n    /** @type {number|undefined} */ this.get(_ol_GeolocationProperty_.ALTITUDE_ACCURACY)\n  );\n};\n\n\n/**\n * Get the heading as radians clockwise from North.\n * @return {number|undefined} The heading of the device in radians from north.\n * @observable\n * @api\n */\n_ol_Geolocation_.prototype.getHeading = function() {\n  return (\n    /** @type {number|undefined} */ this.get(_ol_GeolocationProperty_.HEADING)\n  );\n};\n\n\n/**\n * Get the position of the device.\n * @return {ol.Coordinate|undefined} The current position of the device reported\n *     in the current projection.\n * @observable\n * @api\n */\n_ol_Geolocation_.prototype.getPosition = function() {\n  return (\n    /** @type {ol.Coordinate|undefined} */ this.get(_ol_GeolocationProperty_.POSITION)\n  );\n};\n\n\n/**\n * Get the projection associated with the position.\n * @return {ol.proj.Projection|undefined} The projection the position is\n *     reported in.\n * @observable\n * @api\n */\n_ol_Geolocation_.prototype.getProjection = function() {\n  return (\n    /** @type {ol.proj.Projection|undefined} */ this.get(_ol_GeolocationProperty_.PROJECTION)\n  );\n};\n\n\n/**\n * Get the speed in meters per second.\n * @return {number|undefined} The instantaneous speed of the device in meters\n *     per second.\n * @observable\n * @api\n */\n_ol_Geolocation_.prototype.getSpeed = function() {\n  return (\n    /** @type {number|undefined} */ this.get(_ol_GeolocationProperty_.SPEED)\n  );\n};\n\n\n/**\n * Determine if the device location is being tracked.\n * @return {boolean} The device location is being tracked.\n * @observable\n * @api\n */\n_ol_Geolocation_.prototype.getTracking = function() {\n  return (\n    /** @type {boolean} */ this.get(_ol_GeolocationProperty_.TRACKING)\n  );\n};\n\n\n/**\n * Get the tracking options.\n * @see http://www.w3.org/TR/geolocation-API/#position-options\n * @return {GeolocationPositionOptions|undefined} PositionOptions as defined by\n *     the [HTML5 Geolocation spec\n *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).\n * @observable\n * @api\n */\n_ol_Geolocation_.prototype.getTrackingOptions = function() {\n  return (\n    /** @type {GeolocationPositionOptions|undefined} */ this.get(_ol_GeolocationProperty_.TRACKING_OPTIONS)\n  );\n};\n\n\n/**\n * Set the projection to use for transforming the coordinates.\n * @param {ol.ProjectionLike} projection The projection the position is\n *     reported in.\n * @observable\n * @api\n */\n_ol_Geolocation_.prototype.setProjection = function(projection) {\n  this.set(_ol_GeolocationProperty_.PROJECTION, _ol_proj_.get(projection));\n};\n\n\n/**\n * Enable or disable tracking.\n * @param {boolean} tracking Enable tracking.\n * @observable\n * @api\n */\n_ol_Geolocation_.prototype.setTracking = function(tracking) {\n  this.set(_ol_GeolocationProperty_.TRACKING, tracking);\n};\n\n\n/**\n * Set the tracking options.\n * @see http://www.w3.org/TR/geolocation-API/#position-options\n * @param {GeolocationPositionOptions} options PositionOptions as defined by the\n *     [HTML5 Geolocation spec\n *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).\n * @observable\n * @api\n */\n_ol_Geolocation_.prototype.setTrackingOptions = function(options) {\n  this.set(_ol_GeolocationProperty_.TRACKING_OPTIONS, options);\n};\nexport default _ol_Geolocation_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ol/geolocation.js\n// module id = 238\n// module chunks = 0","/**\n * @enum {string}\n */\nvar _ol_GeolocationProperty_ = {\n  ACCURACY: 'accuracy',\n  ACCURACY_GEOMETRY: 'accuracyGeometry',\n  ALTITUDE: 'altitude',\n  ALTITUDE_ACCURACY: 'altitudeAccuracy',\n  HEADING: 'heading',\n  POSITION: 'position',\n  PROJECTION: 'projection',\n  SPEED: 'speed',\n  TRACKING: 'tracking',\n  TRACKING_OPTIONS: 'trackingOptions'\n};\n\nexport default _ol_GeolocationProperty_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ol/geolocationproperty.js\n// module id = 239\n// module chunks = 0","import _ol_asserts_ from './asserts';\nimport _ol_events_ from './events';\nimport _ol_events_EventType_ from './events/eventtype';\nimport _ol_ from './index';\nimport _ol_Object_ from './object';\nimport _ol_geom_Geometry_ from './geom/geometry';\nimport _ol_style_Style_ from './style/style';\n\n/**\n * @classdesc\n * A vector object for geographic features with a geometry and other\n * attribute properties, similar to the features in vector file formats like\n * GeoJSON.\n *\n * Features can be styled individually with `setStyle`; otherwise they use the\n * style of their vector layer.\n *\n * Note that attribute properties are set as {@link ol.Object} properties on\n * the feature object, so they are observable, and have get/set accessors.\n *\n * Typically, a feature has a single geometry property. You can set the\n * geometry using the `setGeometry` method and get it with `getGeometry`.\n * It is possible to store more than one geometry on a feature using attribute\n * properties. By default, the geometry used for rendering is identified by\n * the property name `geometry`. If you want to use another geometry property\n * for rendering, use the `setGeometryName` method to change the attribute\n * property associated with the geometry for the feature.  For example:\n *\n * ```js\n * var feature = new ol.Feature({\n *   geometry: new ol.geom.Polygon(polyCoords),\n *   labelPoint: new ol.geom.Point(labelCoords),\n *   name: 'My Polygon'\n * });\n *\n * // get the polygon geometry\n * var poly = feature.getGeometry();\n *\n * // Render the feature as a point using the coordinates from labelPoint\n * feature.setGeometryName('labelPoint');\n *\n * // get the point geometry\n * var point = feature.getGeometry();\n * ```\n *\n * @constructor\n * @extends {ol.Object}\n * @param {ol.geom.Geometry|Object.<string, *>=} opt_geometryOrProperties\n *     You may pass a Geometry object directly, or an object literal\n *     containing properties.  If you pass an object literal, you may\n *     include a Geometry associated with a `geometry` key.\n * @api\n */\nvar _ol_Feature_ = function(opt_geometryOrProperties) {\n\n  _ol_Object_.call(this);\n\n  /**\n   * @private\n   * @type {number|string|undefined}\n   */\n  this.id_ = undefined;\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.geometryName_ = 'geometry';\n\n  /**\n   * User provided style.\n   * @private\n   * @type {ol.style.Style|Array.<ol.style.Style>|\n   *     ol.FeatureStyleFunction}\n   */\n  this.style_ = null;\n\n  /**\n   * @private\n   * @type {ol.FeatureStyleFunction|undefined}\n   */\n  this.styleFunction_ = undefined;\n\n  /**\n   * @private\n   * @type {?ol.EventsKey}\n   */\n  this.geometryChangeKey_ = null;\n\n  _ol_events_.listen(\n      this, _ol_Object_.getChangeEventType(this.geometryName_),\n      this.handleGeometryChanged_, this);\n\n  if (opt_geometryOrProperties !== undefined) {\n    if (opt_geometryOrProperties instanceof _ol_geom_Geometry_ ||\n        !opt_geometryOrProperties) {\n      var geometry = opt_geometryOrProperties;\n      this.setGeometry(geometry);\n    } else {\n      /** @type {Object.<string, *>} */\n      var properties = opt_geometryOrProperties;\n      this.setProperties(properties);\n    }\n  }\n};\n\n_ol_.inherits(_ol_Feature_, _ol_Object_);\n\n\n/**\n * Clone this feature. If the original feature has a geometry it\n * is also cloned. The feature id is not set in the clone.\n * @return {ol.Feature} The clone.\n * @api\n */\n_ol_Feature_.prototype.clone = function() {\n  var clone = new _ol_Feature_(this.getProperties());\n  clone.setGeometryName(this.getGeometryName());\n  var geometry = this.getGeometry();\n  if (geometry) {\n    clone.setGeometry(geometry.clone());\n  }\n  var style = this.getStyle();\n  if (style) {\n    clone.setStyle(style);\n  }\n  return clone;\n};\n\n\n/**\n * Get the feature's default geometry.  A feature may have any number of named\n * geometries.  The \"default\" geometry (the one that is rendered by default) is\n * set when calling {@link ol.Feature#setGeometry}.\n * @return {ol.geom.Geometry|undefined} The default geometry for the feature.\n * @api\n * @observable\n */\n_ol_Feature_.prototype.getGeometry = function() {\n  return /** @type {ol.geom.Geometry|undefined} */ (\n    this.get(this.geometryName_));\n};\n\n\n/**\n * Get the feature identifier.  This is a stable identifier for the feature and\n * is either set when reading data from a remote source or set explicitly by\n * calling {@link ol.Feature#setId}.\n * @return {number|string|undefined} Id.\n * @api\n */\n_ol_Feature_.prototype.getId = function() {\n  return this.id_;\n};\n\n\n/**\n * Get the name of the feature's default geometry.  By default, the default\n * geometry is named `geometry`.\n * @return {string} Get the property name associated with the default geometry\n *     for this feature.\n * @api\n */\n_ol_Feature_.prototype.getGeometryName = function() {\n  return this.geometryName_;\n};\n\n\n/**\n * Get the feature's style. Will return what was provided to the\n * {@link ol.Feature#setStyle} method.\n * @return {ol.style.Style|Array.<ol.style.Style>|\n *     ol.FeatureStyleFunction|ol.StyleFunction} The feature style.\n * @api\n */\n_ol_Feature_.prototype.getStyle = function() {\n  return this.style_;\n};\n\n\n/**\n * Get the feature's style function.\n * @return {ol.FeatureStyleFunction|undefined} Return a function\n * representing the current style of this feature.\n * @api\n */\n_ol_Feature_.prototype.getStyleFunction = function() {\n  return this.styleFunction_;\n};\n\n\n/**\n * @private\n */\n_ol_Feature_.prototype.handleGeometryChange_ = function() {\n  this.changed();\n};\n\n\n/**\n * @private\n */\n_ol_Feature_.prototype.handleGeometryChanged_ = function() {\n  if (this.geometryChangeKey_) {\n    _ol_events_.unlistenByKey(this.geometryChangeKey_);\n    this.geometryChangeKey_ = null;\n  }\n  var geometry = this.getGeometry();\n  if (geometry) {\n    this.geometryChangeKey_ = _ol_events_.listen(geometry,\n        _ol_events_EventType_.CHANGE, this.handleGeometryChange_, this);\n  }\n  this.changed();\n};\n\n\n/**\n * Set the default geometry for the feature.  This will update the property\n * with the name returned by {@link ol.Feature#getGeometryName}.\n * @param {ol.geom.Geometry|undefined} geometry The new geometry.\n * @api\n * @observable\n */\n_ol_Feature_.prototype.setGeometry = function(geometry) {\n  this.set(this.geometryName_, geometry);\n};\n\n\n/**\n * Set the style for the feature.  This can be a single style object, an array\n * of styles, or a function that takes a resolution and returns an array of\n * styles. If it is `null` the feature has no style (a `null` style).\n * @param {ol.style.Style|Array.<ol.style.Style>|\n *     ol.FeatureStyleFunction|ol.StyleFunction} style Style for this feature.\n * @api\n * @fires ol.events.Event#event:change\n */\n_ol_Feature_.prototype.setStyle = function(style) {\n  this.style_ = style;\n  this.styleFunction_ = !style ?\n    undefined : _ol_Feature_.createStyleFunction(style);\n  this.changed();\n};\n\n\n/**\n * Set the feature id.  The feature id is considered stable and may be used when\n * requesting features or comparing identifiers returned from a remote source.\n * The feature id can be used with the {@link ol.source.Vector#getFeatureById}\n * method.\n * @param {number|string|undefined} id The feature id.\n * @api\n * @fires ol.events.Event#event:change\n */\n_ol_Feature_.prototype.setId = function(id) {\n  this.id_ = id;\n  this.changed();\n};\n\n\n/**\n * Set the property name to be used when getting the feature's default geometry.\n * When calling {@link ol.Feature#getGeometry}, the value of the property with\n * this name will be returned.\n * @param {string} name The property name of the default geometry.\n * @api\n */\n_ol_Feature_.prototype.setGeometryName = function(name) {\n  _ol_events_.unlisten(\n      this, _ol_Object_.getChangeEventType(this.geometryName_),\n      this.handleGeometryChanged_, this);\n  this.geometryName_ = name;\n  _ol_events_.listen(\n      this, _ol_Object_.getChangeEventType(this.geometryName_),\n      this.handleGeometryChanged_, this);\n  this.handleGeometryChanged_();\n};\n\n\n/**\n * Convert the provided object into a feature style function.  Functions passed\n * through unchanged.  Arrays of ol.style.Style or single style objects wrapped\n * in a new feature style function.\n * @param {ol.FeatureStyleFunction|!Array.<ol.style.Style>|!ol.style.Style} obj\n *     A feature style function, a single style, or an array of styles.\n * @return {ol.FeatureStyleFunction} A style function.\n */\n_ol_Feature_.createStyleFunction = function(obj) {\n  var styleFunction;\n\n  if (typeof obj === 'function') {\n    if (obj.length == 2) {\n      styleFunction = function(resolution) {\n        return /** @type {ol.StyleFunction} */ (obj)(this, resolution);\n      };\n    } else {\n      styleFunction = obj;\n    }\n  } else {\n    /**\n     * @type {Array.<ol.style.Style>}\n     */\n    var styles;\n    if (Array.isArray(obj)) {\n      styles = obj;\n    } else {\n      _ol_asserts_.assert(obj instanceof _ol_style_Style_,\n          41); // Expected an `ol.style.Style` or an array of `ol.style.Style`\n      styles = [obj];\n    }\n    styleFunction = function() {\n      return styles;\n    };\n  }\n  return styleFunction;\n};\nexport default _ol_Feature_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ol/feature.js\n// module id = 240\n// module chunks = 0","// FIXME bulk feature upload - suppress events\n// FIXME make change-detection more refined (notably, geometry hint)\n\nimport _ol_ from '../index';\nimport _ol_Collection_ from '../collection';\nimport _ol_CollectionEventType_ from '../collectioneventtype';\nimport _ol_ObjectEventType_ from '../objecteventtype';\nimport _ol_array_ from '../array';\nimport _ol_asserts_ from '../asserts';\nimport _ol_events_ from '../events';\nimport _ol_events_Event_ from '../events/event';\nimport _ol_events_EventType_ from '../events/eventtype';\nimport _ol_extent_ from '../extent';\nimport _ol_featureloader_ from '../featureloader';\nimport _ol_functions_ from '../functions';\nimport _ol_loadingstrategy_ from '../loadingstrategy';\nimport _ol_obj_ from '../obj';\nimport _ol_source_Source_ from '../source/source';\nimport _ol_source_State_ from '../source/state';\nimport _ol_source_VectorEventType_ from '../source/vectoreventtype';\nimport _ol_structs_RBush_ from '../structs/rbush';\n\n/**\n * @classdesc\n * Provides a source of features for vector layers. Vector features provided\n * by this source are suitable for editing. See {@link ol.source.VectorTile} for\n * vector data that is optimized for rendering.\n *\n * @constructor\n * @extends {ol.source.Source}\n * @fires ol.source.Vector.Event\n * @param {olx.source.VectorOptions=} opt_options Vector source options.\n * @api\n */\nvar _ol_source_Vector_ = function(opt_options) {\n\n  var options = opt_options || {};\n\n  _ol_source_Source_.call(this, {\n    attributions: options.attributions,\n    logo: options.logo,\n    projection: undefined,\n    state: _ol_source_State_.READY,\n    wrapX: options.wrapX !== undefined ? options.wrapX : true\n  });\n\n  /**\n   * @private\n   * @type {ol.FeatureLoader}\n   */\n  this.loader_ = _ol_.nullFunction;\n\n  /**\n   * @private\n   * @type {ol.format.Feature|undefined}\n   */\n  this.format_ = options.format;\n\n  /**\n   * @private\n   * @type {boolean}\n   */\n  this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n\n  /**\n   * @private\n   * @type {string|ol.FeatureUrlFunction|undefined}\n   */\n  this.url_ = options.url;\n\n  if (options.loader !== undefined) {\n    this.loader_ = options.loader;\n  } else if (this.url_ !== undefined) {\n    _ol_asserts_.assert(this.format_, 7); // `format` must be set when `url` is set\n    // create a XHR feature loader for \"url\" and \"format\"\n    this.loader_ = _ol_featureloader_.xhr(this.url_, /** @type {ol.format.Feature} */ (this.format_));\n  }\n\n  /**\n   * @private\n   * @type {ol.LoadingStrategy}\n   */\n  this.strategy_ = options.strategy !== undefined ? options.strategy :\n    _ol_loadingstrategy_.all;\n\n  var useSpatialIndex =\n      options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;\n\n  /**\n   * @private\n   * @type {ol.structs.RBush.<ol.Feature>}\n   */\n  this.featuresRtree_ = useSpatialIndex ? new _ol_structs_RBush_() : null;\n\n  /**\n   * @private\n   * @type {ol.structs.RBush.<{extent: ol.Extent}>}\n   */\n  this.loadedExtentsRtree_ = new _ol_structs_RBush_();\n\n  /**\n   * @private\n   * @type {Object.<string, ol.Feature>}\n   */\n  this.nullGeometryFeatures_ = {};\n\n  /**\n   * A lookup of features by id (the return from feature.getId()).\n   * @private\n   * @type {Object.<string, ol.Feature>}\n   */\n  this.idIndex_ = {};\n\n  /**\n   * A lookup of features without id (keyed by ol.getUid(feature)).\n   * @private\n   * @type {Object.<string, ol.Feature>}\n   */\n  this.undefIdIndex_ = {};\n\n  /**\n   * @private\n   * @type {Object.<string, Array.<ol.EventsKey>>}\n   */\n  this.featureChangeKeys_ = {};\n\n  /**\n   * @private\n   * @type {ol.Collection.<ol.Feature>}\n   */\n  this.featuresCollection_ = null;\n\n  var collection, features;\n  if (options.features instanceof _ol_Collection_) {\n    collection = options.features;\n    features = collection.getArray();\n  } else if (Array.isArray(options.features)) {\n    features = options.features;\n  }\n  if (!useSpatialIndex && collection === undefined) {\n    collection = new _ol_Collection_(features);\n  }\n  if (features !== undefined) {\n    this.addFeaturesInternal(features);\n  }\n  if (collection !== undefined) {\n    this.bindFeaturesCollection_(collection);\n  }\n\n};\n\n_ol_.inherits(_ol_source_Vector_, _ol_source_Source_);\n\n\n/**\n * Add a single feature to the source.  If you want to add a batch of features\n * at once, call {@link ol.source.Vector#addFeatures source.addFeatures()}\n * instead. A feature will not be added to the source if feature with\n * the same id is already there. The reason for this behavior is to avoid\n * feature duplication when using bbox or tile loading strategies.\n * @param {ol.Feature} feature Feature to add.\n * @api\n */\n_ol_source_Vector_.prototype.addFeature = function(feature) {\n  this.addFeatureInternal(feature);\n  this.changed();\n};\n\n\n/**\n * Add a feature without firing a `change` event.\n * @param {ol.Feature} feature Feature.\n * @protected\n */\n_ol_source_Vector_.prototype.addFeatureInternal = function(feature) {\n  var featureKey = _ol_.getUid(feature).toString();\n\n  if (!this.addToIndex_(featureKey, feature)) {\n    return;\n  }\n\n  this.setupChangeEvents_(featureKey, feature);\n\n  var geometry = feature.getGeometry();\n  if (geometry) {\n    var extent = geometry.getExtent();\n    if (this.featuresRtree_) {\n      this.featuresRtree_.insert(extent, feature);\n    }\n  } else {\n    this.nullGeometryFeatures_[featureKey] = feature;\n  }\n\n  this.dispatchEvent(\n      new _ol_source_Vector_.Event(_ol_source_VectorEventType_.ADDFEATURE, feature));\n};\n\n\n/**\n * @param {string} featureKey Unique identifier for the feature.\n * @param {ol.Feature} feature The feature.\n * @private\n */\n_ol_source_Vector_.prototype.setupChangeEvents_ = function(featureKey, feature) {\n  this.featureChangeKeys_[featureKey] = [\n    _ol_events_.listen(feature, _ol_events_EventType_.CHANGE,\n        this.handleFeatureChange_, this),\n    _ol_events_.listen(feature, _ol_ObjectEventType_.PROPERTYCHANGE,\n        this.handleFeatureChange_, this)\n  ];\n};\n\n\n/**\n * @param {string} featureKey Unique identifier for the feature.\n * @param {ol.Feature} feature The feature.\n * @return {boolean} The feature is \"valid\", in the sense that it is also a\n *     candidate for insertion into the Rtree.\n * @private\n */\n_ol_source_Vector_.prototype.addToIndex_ = function(featureKey, feature) {\n  var valid = true;\n  var id = feature.getId();\n  if (id !== undefined) {\n    if (!(id.toString() in this.idIndex_)) {\n      this.idIndex_[id.toString()] = feature;\n    } else {\n      valid = false;\n    }\n  } else {\n    _ol_asserts_.assert(!(featureKey in this.undefIdIndex_),\n        30); // The passed `feature` was already added to the source\n    this.undefIdIndex_[featureKey] = feature;\n  }\n  return valid;\n};\n\n\n/**\n * Add a batch of features to the source.\n * @param {Array.<ol.Feature>} features Features to add.\n * @api\n */\n_ol_source_Vector_.prototype.addFeatures = function(features) {\n  this.addFeaturesInternal(features);\n  this.changed();\n};\n\n\n/**\n * Add features without firing a `change` event.\n * @param {Array.<ol.Feature>} features Features.\n * @protected\n */\n_ol_source_Vector_.prototype.addFeaturesInternal = function(features) {\n  var featureKey, i, length, feature;\n\n  var extents = [];\n  var newFeatures = [];\n  var geometryFeatures = [];\n\n  for (i = 0, length = features.length; i < length; i++) {\n    feature = features[i];\n    featureKey = _ol_.getUid(feature).toString();\n    if (this.addToIndex_(featureKey, feature)) {\n      newFeatures.push(feature);\n    }\n  }\n\n  for (i = 0, length = newFeatures.length; i < length; i++) {\n    feature = newFeatures[i];\n    featureKey = _ol_.getUid(feature).toString();\n    this.setupChangeEvents_(featureKey, feature);\n\n    var geometry = feature.getGeometry();\n    if (geometry) {\n      var extent = geometry.getExtent();\n      extents.push(extent);\n      geometryFeatures.push(feature);\n    } else {\n      this.nullGeometryFeatures_[featureKey] = feature;\n    }\n  }\n  if (this.featuresRtree_) {\n    this.featuresRtree_.load(extents, geometryFeatures);\n  }\n\n  for (i = 0, length = newFeatures.length; i < length; i++) {\n    this.dispatchEvent(new _ol_source_Vector_.Event(\n        _ol_source_VectorEventType_.ADDFEATURE, newFeatures[i]));\n  }\n};\n\n\n/**\n * @param {!ol.Collection.<ol.Feature>} collection Collection.\n * @private\n */\n_ol_source_Vector_.prototype.bindFeaturesCollection_ = function(collection) {\n  var modifyingCollection = false;\n  _ol_events_.listen(this, _ol_source_VectorEventType_.ADDFEATURE,\n      function(evt) {\n        if (!modifyingCollection) {\n          modifyingCollection = true;\n          collection.push(evt.feature);\n          modifyingCollection = false;\n        }\n      });\n  _ol_events_.listen(this, _ol_source_VectorEventType_.REMOVEFEATURE,\n      function(evt) {\n        if (!modifyingCollection) {\n          modifyingCollection = true;\n          collection.remove(evt.feature);\n          modifyingCollection = false;\n        }\n      });\n  _ol_events_.listen(collection, _ol_CollectionEventType_.ADD,\n      function(evt) {\n        if (!modifyingCollection) {\n          modifyingCollection = true;\n          this.addFeature(/** @type {ol.Feature} */ (evt.element));\n          modifyingCollection = false;\n        }\n      }, this);\n  _ol_events_.listen(collection, _ol_CollectionEventType_.REMOVE,\n      function(evt) {\n        if (!modifyingCollection) {\n          modifyingCollection = true;\n          this.removeFeature(/** @type {ol.Feature} */ (evt.element));\n          modifyingCollection = false;\n        }\n      }, this);\n  this.featuresCollection_ = collection;\n};\n\n\n/**\n * Remove all features from the source.\n * @param {boolean=} opt_fast Skip dispatching of {@link removefeature} events.\n * @api\n */\n_ol_source_Vector_.prototype.clear = function(opt_fast) {\n  if (opt_fast) {\n    for (var featureId in this.featureChangeKeys_) {\n      var keys = this.featureChangeKeys_[featureId];\n      keys.forEach(_ol_events_.unlistenByKey);\n    }\n    if (!this.featuresCollection_) {\n      this.featureChangeKeys_ = {};\n      this.idIndex_ = {};\n      this.undefIdIndex_ = {};\n    }\n  } else {\n    if (this.featuresRtree_) {\n      this.featuresRtree_.forEach(this.removeFeatureInternal, this);\n      for (var id in this.nullGeometryFeatures_) {\n        this.removeFeatureInternal(this.nullGeometryFeatures_[id]);\n      }\n    }\n  }\n  if (this.featuresCollection_) {\n    this.featuresCollection_.clear();\n  }\n\n  if (this.featuresRtree_) {\n    this.featuresRtree_.clear();\n  }\n  this.loadedExtentsRtree_.clear();\n  this.nullGeometryFeatures_ = {};\n\n  var clearEvent = new _ol_source_Vector_.Event(_ol_source_VectorEventType_.CLEAR);\n  this.dispatchEvent(clearEvent);\n  this.changed();\n};\n\n\n/**\n * Iterate through all features on the source, calling the provided callback\n * with each one.  If the callback returns any \"truthy\" value, iteration will\n * stop and the function will return the same value.\n *\n * @param {function(this: T, ol.Feature): S} callback Called with each feature\n *     on the source.  Return a truthy value to stop iteration.\n * @param {T=} opt_this The object to use as `this` in the callback.\n * @return {S|undefined} The return value from the last call to the callback.\n * @template T,S\n * @api\n */\n_ol_source_Vector_.prototype.forEachFeature = function(callback, opt_this) {\n  if (this.featuresRtree_) {\n    return this.featuresRtree_.forEach(callback, opt_this);\n  } else if (this.featuresCollection_) {\n    return this.featuresCollection_.forEach(callback, opt_this);\n  }\n};\n\n\n/**\n * Iterate through all features whose geometries contain the provided\n * coordinate, calling the callback with each feature.  If the callback returns\n * a \"truthy\" value, iteration will stop and the function will return the same\n * value.\n *\n * @param {ol.Coordinate} coordinate Coordinate.\n * @param {function(this: T, ol.Feature): S} callback Called with each feature\n *     whose goemetry contains the provided coordinate.\n * @param {T=} opt_this The object to use as `this` in the callback.\n * @return {S|undefined} The return value from the last call to the callback.\n * @template T,S\n */\n_ol_source_Vector_.prototype.forEachFeatureAtCoordinateDirect = function(coordinate, callback, opt_this) {\n  var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];\n  return this.forEachFeatureInExtent(extent, function(feature) {\n    var geometry = feature.getGeometry();\n    if (geometry.intersectsCoordinate(coordinate)) {\n      return callback.call(opt_this, feature);\n    } else {\n      return undefined;\n    }\n  });\n};\n\n\n/**\n * Iterate through all features whose bounding box intersects the provided\n * extent (note that the feature's geometry may not intersect the extent),\n * calling the callback with each feature.  If the callback returns a \"truthy\"\n * value, iteration will stop and the function will return the same value.\n *\n * If you are interested in features whose geometry intersects an extent, call\n * the {@link ol.source.Vector#forEachFeatureIntersectingExtent\n * source.forEachFeatureIntersectingExtent()} method instead.\n *\n * When `useSpatialIndex` is set to false, this method will loop through all\n * features, equivalent to {@link ol.source.Vector#forEachFeature}.\n *\n * @param {ol.Extent} extent Extent.\n * @param {function(this: T, ol.Feature): S} callback Called with each feature\n *     whose bounding box intersects the provided extent.\n * @param {T=} opt_this The object to use as `this` in the callback.\n * @return {S|undefined} The return value from the last call to the callback.\n * @template T,S\n * @api\n */\n_ol_source_Vector_.prototype.forEachFeatureInExtent = function(extent, callback, opt_this) {\n  if (this.featuresRtree_) {\n    return this.featuresRtree_.forEachInExtent(extent, callback, opt_this);\n  } else if (this.featuresCollection_) {\n    return this.featuresCollection_.forEach(callback, opt_this);\n  }\n};\n\n\n/**\n * Iterate through all features whose geometry intersects the provided extent,\n * calling the callback with each feature.  If the callback returns a \"truthy\"\n * value, iteration will stop and the function will return the same value.\n *\n * If you only want to test for bounding box intersection, call the\n * {@link ol.source.Vector#forEachFeatureInExtent\n * source.forEachFeatureInExtent()} method instead.\n *\n * @param {ol.Extent} extent Extent.\n * @param {function(this: T, ol.Feature): S} callback Called with each feature\n *     whose geometry intersects the provided extent.\n * @param {T=} opt_this The object to use as `this` in the callback.\n * @return {S|undefined} The return value from the last call to the callback.\n * @template T,S\n * @api\n */\n_ol_source_Vector_.prototype.forEachFeatureIntersectingExtent = function(extent, callback, opt_this) {\n  return this.forEachFeatureInExtent(extent,\n      /**\n       * @param {ol.Feature} feature Feature.\n       * @return {S|undefined} The return value from the last call to the callback.\n       * @template S\n       */\n      function(feature) {\n        var geometry = feature.getGeometry();\n        if (geometry.intersectsExtent(extent)) {\n          var result = callback.call(opt_this, feature);\n          if (result) {\n            return result;\n          }\n        }\n      });\n};\n\n\n/**\n * Get the features collection associated with this source. Will be `null`\n * unless the source was configured with `useSpatialIndex` set to `false`, or\n * with an {@link ol.Collection} as `features`.\n * @return {ol.Collection.<ol.Feature>} The collection of features.\n * @api\n */\n_ol_source_Vector_.prototype.getFeaturesCollection = function() {\n  return this.featuresCollection_;\n};\n\n\n/**\n * Get all features on the source in random order.\n * @return {Array.<ol.Feature>} Features.\n * @api\n */\n_ol_source_Vector_.prototype.getFeatures = function() {\n  var features;\n  if (this.featuresCollection_) {\n    features = this.featuresCollection_.getArray();\n  } else if (this.featuresRtree_) {\n    features = this.featuresRtree_.getAll();\n    if (!_ol_obj_.isEmpty(this.nullGeometryFeatures_)) {\n      _ol_array_.extend(\n          features, _ol_obj_.getValues(this.nullGeometryFeatures_));\n    }\n  }\n  return /** @type {Array.<ol.Feature>} */ (features);\n};\n\n\n/**\n * Get all features whose geometry intersects the provided coordinate.\n * @param {ol.Coordinate} coordinate Coordinate.\n * @return {Array.<ol.Feature>} Features.\n * @api\n */\n_ol_source_Vector_.prototype.getFeaturesAtCoordinate = function(coordinate) {\n  var features = [];\n  this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {\n    features.push(feature);\n  });\n  return features;\n};\n\n\n/**\n * Get all features in the provided extent.  Note that this returns an array of\n * all features intersecting the given extent in random order (so it may include\n * features whose geometries do not intersect the extent).\n *\n * This method is not available when the source is configured with\n * `useSpatialIndex` set to `false`.\n * @param {ol.Extent} extent Extent.\n * @return {Array.<ol.Feature>} Features.\n * @api\n */\n_ol_source_Vector_.prototype.getFeaturesInExtent = function(extent) {\n  return this.featuresRtree_.getInExtent(extent);\n};\n\n\n/**\n * Get the closest feature to the provided coordinate.\n *\n * This method is not available when the source is configured with\n * `useSpatialIndex` set to `false`.\n * @param {ol.Coordinate} coordinate Coordinate.\n * @param {function(ol.Feature):boolean=} opt_filter Feature filter function.\n *     The filter function will receive one argument, the {@link ol.Feature feature}\n *     and it should return a boolean value. By default, no filtering is made.\n * @return {ol.Feature} Closest feature.\n * @api\n */\n_ol_source_Vector_.prototype.getClosestFeatureToCoordinate = function(coordinate, opt_filter) {\n  // Find the closest feature using branch and bound.  We start searching an\n  // infinite extent, and find the distance from the first feature found.  This\n  // becomes the closest feature.  We then compute a smaller extent which any\n  // closer feature must intersect.  We continue searching with this smaller\n  // extent, trying to find a closer feature.  Every time we find a closer\n  // feature, we update the extent being searched so that any even closer\n  // feature must intersect it.  We continue until we run out of features.\n  var x = coordinate[0];\n  var y = coordinate[1];\n  var closestFeature = null;\n  var closestPoint = [NaN, NaN];\n  var minSquaredDistance = Infinity;\n  var extent = [-Infinity, -Infinity, Infinity, Infinity];\n  var filter = opt_filter ? opt_filter : _ol_functions_.TRUE;\n  this.featuresRtree_.forEachInExtent(extent,\n      /**\n       * @param {ol.Feature} feature Feature.\n       */\n      function(feature) {\n        if (filter(feature)) {\n          var geometry = feature.getGeometry();\n          var previousMinSquaredDistance = minSquaredDistance;\n          minSquaredDistance = geometry.closestPointXY(\n              x, y, closestPoint, minSquaredDistance);\n          if (minSquaredDistance < previousMinSquaredDistance) {\n            closestFeature = feature;\n            // This is sneaky.  Reduce the extent that it is currently being\n            // searched while the R-Tree traversal using this same extent object\n            // is still in progress.  This is safe because the new extent is\n            // strictly contained by the old extent.\n            var minDistance = Math.sqrt(minSquaredDistance);\n            extent[0] = x - minDistance;\n            extent[1] = y - minDistance;\n            extent[2] = x + minDistance;\n            extent[3] = y + minDistance;\n          }\n        }\n      });\n  return closestFeature;\n};\n\n\n/**\n * Get the extent of the features currently in the source.\n *\n * This method is not available when the source is configured with\n * `useSpatialIndex` set to `false`.\n * @param {ol.Extent=} opt_extent Destination extent. If provided, no new extent\n *     will be created. Instead, that extent's coordinates will be overwritten.\n * @return {ol.Extent} Extent.\n * @api\n */\n_ol_source_Vector_.prototype.getExtent = function(opt_extent) {\n  return this.featuresRtree_.getExtent(opt_extent);\n};\n\n\n/**\n * Get a feature by its identifier (the value returned by feature.getId()).\n * Note that the index treats string and numeric identifiers as the same.  So\n * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.\n *\n * @param {string|number} id Feature identifier.\n * @return {ol.Feature} The feature (or `null` if not found).\n * @api\n */\n_ol_source_Vector_.prototype.getFeatureById = function(id) {\n  var feature = this.idIndex_[id.toString()];\n  return feature !== undefined ? feature : null;\n};\n\n\n/**\n * Get the format associated with this source.\n *\n * @return {ol.format.Feature|undefined} The feature format.\n * @api\n */\n_ol_source_Vector_.prototype.getFormat = function() {\n  return this.format_;\n};\n\n\n/**\n * @return {boolean} The source can have overlapping geometries.\n */\n_ol_source_Vector_.prototype.getOverlaps = function() {\n  return this.overlaps_;\n};\n\n\n/**\n * @override\n */\n_ol_source_Vector_.prototype.getResolutions = function() {};\n\n\n/**\n * Get the url associated with this source.\n *\n * @return {string|ol.FeatureUrlFunction|undefined} The url.\n * @api\n */\n_ol_source_Vector_.prototype.getUrl = function() {\n  return this.url_;\n};\n\n\n/**\n * @param {ol.events.Event} event Event.\n * @private\n */\n_ol_source_Vector_.prototype.handleFeatureChange_ = function(event) {\n  var feature = /** @type {ol.Feature} */ (event.target);\n  var featureKey = _ol_.getUid(feature).toString();\n  var geometry = feature.getGeometry();\n  if (!geometry) {\n    if (!(featureKey in this.nullGeometryFeatures_)) {\n      if (this.featuresRtree_) {\n        this.featuresRtree_.remove(feature);\n      }\n      this.nullGeometryFeatures_[featureKey] = feature;\n    }\n  } else {\n    var extent = geometry.getExtent();\n    if (featureKey in this.nullGeometryFeatures_) {\n      delete this.nullGeometryFeatures_[featureKey];\n      if (this.featuresRtree_) {\n        this.featuresRtree_.insert(extent, feature);\n      }\n    } else {\n      if (this.featuresRtree_) {\n        this.featuresRtree_.update(extent, feature);\n      }\n    }\n  }\n  var id = feature.getId();\n  if (id !== undefined) {\n    var sid = id.toString();\n    if (featureKey in this.undefIdIndex_) {\n      delete this.undefIdIndex_[featureKey];\n      this.idIndex_[sid] = feature;\n    } else {\n      if (this.idIndex_[sid] !== feature) {\n        this.removeFromIdIndex_(feature);\n        this.idIndex_[sid] = feature;\n      }\n    }\n  } else {\n    if (!(featureKey in this.undefIdIndex_)) {\n      this.removeFromIdIndex_(feature);\n      this.undefIdIndex_[featureKey] = feature;\n    }\n  }\n  this.changed();\n  this.dispatchEvent(new _ol_source_Vector_.Event(\n      _ol_source_VectorEventType_.CHANGEFEATURE, feature));\n};\n\n\n/**\n * @return {boolean} Is empty.\n */\n_ol_source_Vector_.prototype.isEmpty = function() {\n  return this.featuresRtree_.isEmpty() &&\n      _ol_obj_.isEmpty(this.nullGeometryFeatures_);\n};\n\n\n/**\n * @param {ol.Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @param {ol.proj.Projection} projection Projection.\n */\n_ol_source_Vector_.prototype.loadFeatures = function(\n    extent, resolution, projection) {\n  var loadedExtentsRtree = this.loadedExtentsRtree_;\n  var extentsToLoad = this.strategy_(extent, resolution);\n  var i, ii;\n  for (i = 0, ii = extentsToLoad.length; i < ii; ++i) {\n    var extentToLoad = extentsToLoad[i];\n    var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad,\n        /**\n         * @param {{extent: ol.Extent}} object Object.\n         * @return {boolean} Contains.\n         */\n        function(object) {\n          return _ol_extent_.containsExtent(object.extent, extentToLoad);\n        });\n    if (!alreadyLoaded) {\n      this.loader_.call(this, extentToLoad, resolution, projection);\n      loadedExtentsRtree.insert(extentToLoad, {extent: extentToLoad.slice()});\n    }\n  }\n};\n\n\n/**\n * Remove a single feature from the source.  If you want to remove all features\n * at once, use the {@link ol.source.Vector#clear source.clear()} method\n * instead.\n * @param {ol.Feature} feature Feature to remove.\n * @api\n */\n_ol_source_Vector_.prototype.removeFeature = function(feature) {\n  var featureKey = _ol_.getUid(feature).toString();\n  if (featureKey in this.nullGeometryFeatures_) {\n    delete this.nullGeometryFeatures_[featureKey];\n  } else {\n    if (this.featuresRtree_) {\n      this.featuresRtree_.remove(feature);\n    }\n  }\n  this.removeFeatureInternal(feature);\n  this.changed();\n};\n\n\n/**\n * Remove feature without firing a `change` event.\n * @param {ol.Feature} feature Feature.\n * @protected\n */\n_ol_source_Vector_.prototype.removeFeatureInternal = function(feature) {\n  var featureKey = _ol_.getUid(feature).toString();\n  this.featureChangeKeys_[featureKey].forEach(_ol_events_.unlistenByKey);\n  delete this.featureChangeKeys_[featureKey];\n  var id = feature.getId();\n  if (id !== undefined) {\n    delete this.idIndex_[id.toString()];\n  } else {\n    delete this.undefIdIndex_[featureKey];\n  }\n  this.dispatchEvent(new _ol_source_Vector_.Event(\n      _ol_source_VectorEventType_.REMOVEFEATURE, feature));\n};\n\n\n/**\n * Remove a feature from the id index.  Called internally when the feature id\n * may have changed.\n * @param {ol.Feature} feature The feature.\n * @return {boolean} Removed the feature from the index.\n * @private\n */\n_ol_source_Vector_.prototype.removeFromIdIndex_ = function(feature) {\n  var removed = false;\n  for (var id in this.idIndex_) {\n    if (this.idIndex_[id] === feature) {\n      delete this.idIndex_[id];\n      removed = true;\n      break;\n    }\n  }\n  return removed;\n};\n\n\n/**\n * @classdesc\n * Events emitted by {@link ol.source.Vector} instances are instances of this\n * type.\n *\n * @constructor\n * @extends {ol.events.Event}\n * @implements {oli.source.Vector.Event}\n * @param {string} type Type.\n * @param {ol.Feature=} opt_feature Feature.\n */\n_ol_source_Vector_.Event = function(type, opt_feature) {\n\n  _ol_events_Event_.call(this, type);\n\n  /**\n   * The feature being added or removed.\n   * @type {ol.Feature|undefined}\n   * @api\n   */\n  this.feature = opt_feature;\n\n};\n_ol_.inherits(_ol_source_Vector_.Event, _ol_events_Event_);\nexport default _ol_source_Vector_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ol/source/vector.js\n// module id = 241\n// module chunks = 0","var _ol_loadingstrategy_ = {};\n\n\n/**\n * Strategy function for loading all features with a single request.\n * @param {ol.Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @return {Array.<ol.Extent>} Extents.\n * @api\n */\n_ol_loadingstrategy_.all = function(extent, resolution) {\n  return [[-Infinity, -Infinity, Infinity, Infinity]];\n};\n\n\n/**\n * Strategy function for loading features based on the view's extent and\n * resolution.\n * @param {ol.Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @return {Array.<ol.Extent>} Extents.\n * @api\n */\n_ol_loadingstrategy_.bbox = function(extent, resolution) {\n  return [extent];\n};\n\n\n/**\n * Creates a strategy function for loading features based on a tile grid.\n * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.\n * @return {function(ol.Extent, number): Array.<ol.Extent>} Loading strategy.\n * @api\n */\n_ol_loadingstrategy_.tile = function(tileGrid) {\n  return (\n  /**\n       * @param {ol.Extent} extent Extent.\n       * @param {number} resolution Resolution.\n       * @return {Array.<ol.Extent>} Extents.\n       */\n    function(extent, resolution) {\n      var z = tileGrid.getZForResolution(resolution);\n      var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n      /** @type {Array.<ol.Extent>} */\n      var extents = [];\n      /** @type {ol.TileCoord} */\n      var tileCoord = [z, 0, 0];\n      for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX;\n        ++tileCoord[1]) {\n        for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY;\n          ++tileCoord[2]) {\n          extents.push(tileGrid.getTileCoordExtent(tileCoord));\n        }\n      }\n      return extents;\n    });\n};\nexport default _ol_loadingstrategy_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ol/loadingstrategy.js\n// module id = 242\n// module chunks = 0","/**\n * @enum {string}\n */\nvar _ol_source_VectorEventType_ = {\n  /**\n   * Triggered when a feature is added to the source.\n   * @event ol.source.Vector.Event#addfeature\n   * @api\n   */\n  ADDFEATURE: 'addfeature',\n\n  /**\n   * Triggered when a feature is updated.\n   * @event ol.source.Vector.Event#changefeature\n   * @api\n   */\n  CHANGEFEATURE: 'changefeature',\n\n  /**\n   * Triggered when the clear method is called on the source.\n   * @event ol.source.Vector.Event#clear\n   * @api\n   */\n  CLEAR: 'clear',\n\n  /**\n   * Triggered when a feature is removed from the source.\n   * See {@link ol.source.Vector#clear source.clear()} for exceptions.\n   * @event ol.source.Vector.Event#removefeature\n   * @api\n   */\n  REMOVEFEATURE: 'removefeature'\n};\n\nexport default _ol_source_VectorEventType_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ol/source/vectoreventtype.js\n// module id = 243\n// module chunks = 0"],"mappings":";;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACxEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACtWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC5TA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC/0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}