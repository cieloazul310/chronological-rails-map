{"version":3,"file":"app.bundle.js","sources":["webpack:///webpack/bootstrap cbd506e98cc8b0310b75","webpack:///./node_modules/ol/sphere.js"],"sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [], result;\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// objects to store loaded and loading chunks\n \tvar installedChunks = {\n \t\t1: 0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar installedChunkData = installedChunks[chunkId];\n \t\tif(installedChunkData === 0) {\n \t\t\treturn new Promise(function(resolve) { resolve(); });\n \t\t}\n\n \t\t// a Promise means \"currently loading\".\n \t\tif(installedChunkData) {\n \t\t\treturn installedChunkData[2];\n \t\t}\n\n \t\t// setup Promise in chunk cache\n \t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n \t\t});\n \t\tinstalledChunkData[2] = promise;\n\n \t\t// start chunk loading\n \t\tvar head = document.getElementsByTagName('head')[0];\n \t\tvar script = document.createElement('script');\n \t\tscript.type = 'text/javascript';\n \t\tscript.charset = 'utf-8';\n \t\tscript.async = true;\n \t\tscript.timeout = 120000;\n\n \t\tif (__webpack_require__.nc) {\n \t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n \t\t}\n \t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".bundle.js\";\n \t\tvar timeout = setTimeout(onScriptComplete, 120000);\n \t\tscript.onerror = script.onload = onScriptComplete;\n \t\tfunction onScriptComplete() {\n \t\t\t// avoid mem leaks in IE.\n \t\t\tscript.onerror = script.onload = null;\n \t\t\tclearTimeout(timeout);\n \t\t\tvar chunk = installedChunks[chunkId];\n \t\t\tif(chunk !== 0) {\n \t\t\t\tif(chunk) {\n \t\t\t\t\tchunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));\n \t\t\t\t}\n \t\t\t\tinstalledChunks[chunkId] = undefined;\n \t\t\t}\n \t\t};\n \t\thead.appendChild(script);\n\n \t\treturn promise;\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 133);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap cbd506e98cc8b0310b75","/**\n * @license\n * Latitude/longitude spherical geodesy formulae taken from\n * http://www.movable-type.co.uk/scripts/latlong.html\n * Licensed under CC-BY-3.0.\n */\n\nimport _ol_math_ from './math';\nimport _ol_geom_GeometryType_ from './geom/geometrytype';\n\n/**\n * @classdesc\n * Class to create objects that can be used with {@link\n * ol.geom.Polygon.circular}.\n *\n * For example to create a sphere whose radius is equal to the semi-major\n * axis of the WGS84 ellipsoid:\n *\n * ```js\n * var wgs84Sphere= new ol.Sphere(6378137);\n * ```\n *\n * @constructor\n * @param {number} radius Radius.\n * @api\n */\nvar _ol_Sphere_ = function(radius) {\n\n  /**\n   * @type {number}\n   */\n  this.radius = radius;\n\n};\n\n\n/**\n * Returns the geodesic area for a list of coordinates.\n *\n * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007\n *\n * @param {Array.<ol.Coordinate>} coordinates List of coordinates of a linear\n * ring. If the ring is oriented clockwise, the area will be positive,\n * otherwise it will be negative.\n * @return {number} Area.\n * @api\n */\n_ol_Sphere_.prototype.geodesicArea = function(coordinates) {\n  return _ol_Sphere_.getArea_(coordinates, this.radius);\n};\n\n\n/**\n * Returns the distance from c1 to c2 using the haversine formula.\n *\n * @param {ol.Coordinate} c1 Coordinate 1.\n * @param {ol.Coordinate} c2 Coordinate 2.\n * @return {number} Haversine distance.\n * @api\n */\n_ol_Sphere_.prototype.haversineDistance = function(c1, c2) {\n  return _ol_Sphere_.getDistance_(c1, c2, this.radius);\n};\n\n\n/**\n * Returns the coordinate at the given distance and bearing from `c1`.\n *\n * @param {ol.Coordinate} c1 The origin point (`[lon, lat]` in degrees).\n * @param {number} distance The great-circle distance between the origin\n *     point and the target point.\n * @param {number} bearing The bearing (in radians).\n * @return {ol.Coordinate} The target point.\n */\n_ol_Sphere_.prototype.offset = function(c1, distance, bearing) {\n  var lat1 = _ol_math_.toRadians(c1[1]);\n  var lon1 = _ol_math_.toRadians(c1[0]);\n  var dByR = distance / this.radius;\n  var lat = Math.asin(\n      Math.sin(lat1) * Math.cos(dByR) +\n      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));\n  var lon = lon1 + Math.atan2(\n      Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),\n      Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));\n  return [_ol_math_.toDegrees(lon), _ol_math_.toDegrees(lat)];\n};\n\n\n/**\n * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\n * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\n * @type {number}\n */\n_ol_Sphere_.DEFAULT_RADIUS = 6371008.8;\n\n\n/**\n * Get the spherical length of a geometry.  This length is the sum of the\n * great circle distances between coordinates.  For polygons, the length is\n * the sum of all rings.  For points, the length is zero.  For multi-part\n * geometries, the length is the sum of the length of each part.\n * @param {ol.geom.Geometry} geometry A geometry.\n * @param {olx.SphereMetricOptions=} opt_options Options for the length\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n *     You can change this by providing a `projection` option.\n * @return {number} The spherical length (in meters).\n * @api\n */\n_ol_Sphere_.getLength = function(geometry, opt_options) {\n  var options = opt_options || {};\n  var radius = options.radius || _ol_Sphere_.DEFAULT_RADIUS;\n  var projection = options.projection || 'EPSG:3857';\n  geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  var type = geometry.getType();\n  var length = 0;\n  var coordinates, coords, i, ii, j, jj;\n  switch (type) {\n    case _ol_geom_GeometryType_.POINT:\n    case _ol_geom_GeometryType_.MULTI_POINT: {\n      break;\n    }\n    case _ol_geom_GeometryType_.LINE_STRING:\n    case _ol_geom_GeometryType_.LINEAR_RING: {\n      coordinates = /** @type {ol.geom.SimpleGeometry} */ (geometry).getCoordinates();\n      length = _ol_Sphere_.getLength_(coordinates, radius);\n      break;\n    }\n    case _ol_geom_GeometryType_.MULTI_LINE_STRING:\n    case _ol_geom_GeometryType_.POLYGON: {\n      coordinates = /** @type {ol.geom.SimpleGeometry} */ (geometry).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        length += _ol_Sphere_.getLength_(coordinates[i], radius);\n      }\n      break;\n    }\n    case _ol_geom_GeometryType_.MULTI_POLYGON: {\n      coordinates = /** @type {ol.geom.SimpleGeometry} */ (geometry).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        coords = coordinates[i];\n        for (j = 0, jj = coords.length; j < jj; ++j) {\n          length += _ol_Sphere_.getLength_(coords[j], radius);\n        }\n      }\n      break;\n    }\n    case _ol_geom_GeometryType_.GEOMETRY_COLLECTION: {\n      var geometries = /** @type {ol.geom.GeometryCollection} */ (geometry).getGeometries();\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\n        length += _ol_Sphere_.getLength(geometries[i], opt_options);\n      }\n      break;\n    }\n    default: {\n      throw new Error('Unsupported geometry type: ' + type);\n    }\n  }\n  return length;\n};\n\n\n/**\n * Get the cumulative great circle length of linestring coordinates (geographic).\n * @param {Array} coordinates Linestring coordinates.\n * @param {number} radius The sphere radius to use.\n * @return {number} The length (in meters).\n */\n_ol_Sphere_.getLength_ = function(coordinates, radius) {\n  var length = 0;\n  for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {\n    length += _ol_Sphere_.getDistance_(coordinates[i], coordinates[i + 1], radius);\n  }\n  return length;\n};\n\n\n/**\n * Get the great circle distance between two geographic coordinates.\n * @param {Array} c1 Starting coordinate.\n * @param {Array} c2 Ending coordinate.\n * @param {number} radius The sphere radius to use.\n * @return {number} The great circle distance between the points (in meters).\n */\n_ol_Sphere_.getDistance_ = function(c1, c2, radius) {\n  var lat1 = _ol_math_.toRadians(c1[1]);\n  var lat2 = _ol_math_.toRadians(c2[1]);\n  var deltaLatBy2 = (lat2 - lat1) / 2;\n  var deltaLonBy2 = _ol_math_.toRadians(c2[0] - c1[0]) / 2;\n  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +\n      Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) *\n      Math.cos(lat1) * Math.cos(lat2);\n  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n};\n\n\n/**\n * Get the spherical area of a geometry.  This is the area (in meters) assuming\n * that polygon edges are segments of great circles on a sphere.\n * @param {ol.geom.Geometry} geometry A geometry.\n * @param {olx.SphereMetricOptions=} opt_options Options for the area\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n *     You can change this by providing a `projection` option.\n * @return {number} The spherical area (in square meters).\n * @api\n */\n_ol_Sphere_.getArea = function(geometry, opt_options) {\n  var options = opt_options || {};\n  var radius = options.radius || _ol_Sphere_.DEFAULT_RADIUS;\n  var projection = options.projection || 'EPSG:3857';\n  geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  var type = geometry.getType();\n  var area = 0;\n  var coordinates, coords, i, ii, j, jj;\n  switch (type) {\n    case _ol_geom_GeometryType_.POINT:\n    case _ol_geom_GeometryType_.MULTI_POINT:\n    case _ol_geom_GeometryType_.LINE_STRING:\n    case _ol_geom_GeometryType_.MULTI_LINE_STRING:\n    case _ol_geom_GeometryType_.LINEAR_RING: {\n      break;\n    }\n    case _ol_geom_GeometryType_.POLYGON: {\n      coordinates = /** @type {ol.geom.Polygon} */ (geometry).getCoordinates();\n      area = Math.abs(_ol_Sphere_.getArea_(coordinates[0], radius));\n      for (i = 1, ii = coordinates.length; i < ii; ++i) {\n        area -= Math.abs(_ol_Sphere_.getArea_(coordinates[i], radius));\n      }\n      break;\n    }\n    case _ol_geom_GeometryType_.MULTI_POLYGON: {\n      coordinates = /** @type {ol.geom.SimpleGeometry} */ (geometry).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        coords = coordinates[i];\n        area += Math.abs(_ol_Sphere_.getArea_(coords[0], radius));\n        for (j = 1, jj = coords.length; j < jj; ++j) {\n          area -= Math.abs(_ol_Sphere_.getArea_(coords[j], radius));\n        }\n      }\n      break;\n    }\n    case _ol_geom_GeometryType_.GEOMETRY_COLLECTION: {\n      var geometries = /** @type {ol.geom.GeometryCollection} */ (geometry).getGeometries();\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\n        area += _ol_Sphere_.getArea(geometries[i], opt_options);\n      }\n      break;\n    }\n    default: {\n      throw new Error('Unsupported geometry type: ' + type);\n    }\n  }\n  return area;\n};\n\n\n/**\n * Returns the spherical area for a list of coordinates.\n *\n * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007\n *\n * @param {Array.<ol.Coordinate>} coordinates List of coordinates of a linear\n * ring. If the ring is oriented clockwise, the area will be positive,\n * otherwise it will be negative.\n * @param {number} radius The sphere radius.\n * @return {number} Area (in square meters).\n */\n_ol_Sphere_.getArea_ = function(coordinates, radius) {\n  var area = 0, len = coordinates.length;\n  var x1 = coordinates[len - 1][0];\n  var y1 = coordinates[len - 1][1];\n  for (var i = 0; i < len; i++) {\n    var x2 = coordinates[i][0], y2 = coordinates[i][1];\n    area += _ol_math_.toRadians(x2 - x1) *\n        (2 + Math.sin(_ol_math_.toRadians(y1)) +\n        Math.sin(_ol_math_.toRadians(y2)));\n    x1 = x2;\n    y1 = y2;\n  }\n  return area * radius * radius / 2.0;\n};\nexport default _ol_Sphere_;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ol/sphere.js\n// module id = 127\n// module chunks = 1"],"mappings":"AAAA;;;;;ACkDA","sourceRoot":""}